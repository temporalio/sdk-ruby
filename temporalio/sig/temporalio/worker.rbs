module Temporalio
  class Worker
    class Options
      attr_accessor client: Client
      attr_accessor task_queue: String
      attr_accessor activities: Array[Activity::Definition | singleton(Activity::Definition) | Activity::Definition::Info]
      attr_accessor workflows: Array[singleton(Workflow::Definition) | Workflow::Definition::Info]
      attr_accessor tuner: Tuner
      attr_accessor activity_executors: Hash[Symbol, Worker::ActivityExecutor]
      attr_accessor workflow_executor: Worker::WorkflowExecutor
      attr_accessor interceptors: Array[Interceptor::Activity | Interceptor::Workflow]
      attr_accessor build_id: String
      attr_accessor identity: String
      attr_accessor logger: Logger
      attr_accessor max_cached_workflows: Integer
      attr_accessor max_concurrent_workflow_task_polls: Integer
      attr_accessor nonsticky_to_sticky_poll_ratio: Float
      attr_accessor max_concurrent_activity_task_polls: Integer
      attr_accessor no_remote_activities: bool
      attr_accessor sticky_queue_schedule_to_start_timeout: Float
      attr_accessor max_heartbeat_throttle_interval: Float
      attr_accessor default_heartbeat_throttle_interval: Float
      attr_accessor max_activities_per_second: Float?
      attr_accessor max_task_queue_activities_per_second: Float?
      attr_accessor graceful_shutdown_period: Float
      attr_accessor use_worker_versioning: bool
      attr_accessor disable_eager_activity_execution: bool
      attr_accessor illegal_workflow_calls: Hash[String, :all | Array[Symbol]]
      attr_accessor workflow_failure_exception_types: Array[singleton(Exception)]
      attr_accessor workflow_payload_codec_thread_pool: ThreadPool?
      attr_accessor debug_mode: bool

      def initialize: (
        client: Client,
        task_queue: String,
        activities: Array[Activity::Definition | singleton(Activity::Definition) | Activity::Definition::Info],
        workflows: Array[singleton(Workflow::Definition) | Workflow::Definition::Info],
        tuner: Tuner,
        activity_executors: Hash[Symbol, Worker::ActivityExecutor],
        workflow_executor: Worker::WorkflowExecutor,
        interceptors: Array[Interceptor::Activity | Interceptor::Workflow],
        build_id: String,
        identity: String?,
        logger: Logger,
        max_cached_workflows: Integer,
        max_concurrent_workflow_task_polls: Integer,
        nonsticky_to_sticky_poll_ratio: Float,
        max_concurrent_activity_task_polls: Integer,
        no_remote_activities: bool,
        sticky_queue_schedule_to_start_timeout: Float,
        max_heartbeat_throttle_interval: Float,
        default_heartbeat_throttle_interval: Float,
        max_activities_per_second: Float?,
        max_task_queue_activities_per_second: Float?,
        graceful_shutdown_period: Float,
        use_worker_versioning: bool,
        disable_eager_activity_execution: bool,
        illegal_workflow_calls: Hash[String, :all | Array[Symbol]],
        workflow_failure_exception_types: Array[singleton(Exception)],
        workflow_payload_codec_thread_pool: ThreadPool?,
        debug_mode: bool
      ) -> void
    end

    def self.default_build_id: -> String
    def self._load_default_build_id: -> String

    def self.run_all: [T] (
      *Worker workers,
      ?cancellation: Cancellation,
      ?shutdown_signals: Array[String | Integer],
      ?raise_in_block_on_shutdown: Exception?,
      ?wait_block_complete: bool
    ) ?{ -> T } -> T

    def self.default_illegal_workflow_calls: -> Hash[String, :all | Array[Symbol]]

    attr_reader options: Options

    def initialize: (
      client: Client,
      task_queue: String,
      ?activities: Array[Activity::Definition | singleton(Activity::Definition) | Activity::Definition::Info],
      ?workflows: Array[singleton(Workflow::Definition) | Workflow::Definition::Info],
      ?tuner: Tuner,
      ?activity_executors: Hash[Symbol, Worker::ActivityExecutor],
      ?workflow_executor: Worker::WorkflowExecutor,
      ?interceptors: Array[Interceptor::Activity | Interceptor::Workflow],
      ?build_id: String,
      ?identity: String?,
      ?logger: Logger,
      ?max_cached_workflows: Integer,
      ?max_concurrent_workflow_task_polls: Integer,
      ?nonsticky_to_sticky_poll_ratio: Float,
      ?max_concurrent_activity_task_polls: Integer,
      ?no_remote_activities: bool,
      ?sticky_queue_schedule_to_start_timeout: Float,
      ?max_heartbeat_throttle_interval: Float,
      ?default_heartbeat_throttle_interval: Float,
      ?max_activities_per_second: Float?,
      ?max_task_queue_activities_per_second: Float?,
      ?graceful_shutdown_period: Float,
      ?use_worker_versioning: bool,
      ?disable_eager_activity_execution: bool,
      ?illegal_workflow_calls: Hash[String, :all | Array[Symbol]],
      ?workflow_failure_exception_types: Array[singleton(Exception)],
      ?workflow_payload_codec_thread_pool: ThreadPool?,
      ?debug_mode: bool
    ) -> void

    def task_queue: -> String

    def run: [T] (
      ?cancellation: Cancellation,
      ?shutdown_signals: Array[String | Integer],
      ?raise_in_block_on_shutdown: Exception?,
      ?wait_block_complete: bool
    ) ?{ -> T } -> T

    def _worker_shutdown_cancellation: -> Cancellation
    def _initiate_shutdown: -> void
    def _wait_all_complete: -> void
    def _bridge_worker: -> Internal::Bridge::Worker
    def _activity_interceptors: -> Array[Interceptor::Activity]
    def _workflow_interceptors: -> Array[Interceptor::Workflow]
    def _on_poll_bytes: (Internal::Worker::MultiRunner runner, Symbol worker_type, String bytes) -> void
    def _on_shutdown_complete: -> void

    private def to_bridge_slot_supplier_options: (
      Tuner::SlotSupplier slot_supplier
    ) -> Internal::Bridge::Worker::TunerSlotSupplierOptions
  end
end