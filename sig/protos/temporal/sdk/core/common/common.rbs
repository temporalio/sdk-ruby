module Coresdk
  module Common
    class WorkflowIdReusePolicy < ::Protobuf::Enum
      type names = :WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED | :WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE | :WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY | :WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE

      type strings = "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED" | "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE" | "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY" | "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE"

      type tags = 0 | 1 | 2 | 3

      type values = names | strings | tags

      attr_reader name(): names

      attr_reader tag(): tags

      WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED: WorkflowIdReusePolicy

      # Allow start a workflow execution using the same workflow Id, when workflow not running.
      #
      WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE: WorkflowIdReusePolicy

      # Allow start a workflow execution using the same workflow Id, when workflow not running, and the last execution close state is in
      #  [terminated, cancelled, timed out, failed].
      #
      WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: WorkflowIdReusePolicy

      # Do not allow start a workflow execution using the same workflow Id at all.
      #
      WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE: WorkflowIdReusePolicy

      # The type of `#initialize` parameter.
      type init = WorkflowIdReusePolicy | values

      # The type of `repeated` field.
      type field_array = ::Protobuf::Field::FieldArray[WorkflowIdReusePolicy, WorkflowIdReusePolicy | values]

      # The type of `map` field.
      type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, WorkflowIdReusePolicy, WorkflowIdReusePolicy | values]

      type array = ::Array[WorkflowIdReusePolicy | values]

      type hash[KEY] = ::Hash[KEY, WorkflowIdReusePolicy | values]
    end

    # * Possible causes of failure to cancel an external workflow
    #
    class CancelExternalWorkflowExecutionFailedCause < ::Protobuf::Enum
      type names = :CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED | :CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND

      type strings = "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED" | "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND"

      type tags = 0 | 1

      type values = names | strings | tags

      attr_reader name(): names

      attr_reader tag(): tags

      CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED: CancelExternalWorkflowExecutionFailedCause

      CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND: CancelExternalWorkflowExecutionFailedCause

      # The type of `#initialize` parameter.
      type init = CancelExternalWorkflowExecutionFailedCause | values

      # The type of `repeated` field.
      type field_array = ::Protobuf::Field::FieldArray[CancelExternalWorkflowExecutionFailedCause, CancelExternalWorkflowExecutionFailedCause | values]

      # The type of `map` field.
      type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, CancelExternalWorkflowExecutionFailedCause, CancelExternalWorkflowExecutionFailedCause | values]

      type array = ::Array[CancelExternalWorkflowExecutionFailedCause | values]

      type hash[KEY] = ::Hash[KEY, CancelExternalWorkflowExecutionFailedCause | values]
    end

    # * Possible causes of failure to signal an external workflow
    #
    class SignalExternalWorkflowExecutionFailedCause < ::Protobuf::Enum
      type names = :SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED | :SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND

      type strings = "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED" | "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND"

      type tags = 0 | 1

      type values = names | strings | tags

      attr_reader name(): names

      attr_reader tag(): tags

      SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED: SignalExternalWorkflowExecutionFailedCause

      SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND: SignalExternalWorkflowExecutionFailedCause

      # The type of `#initialize` parameter.
      type init = SignalExternalWorkflowExecutionFailedCause | values

      # The type of `repeated` field.
      type field_array = ::Protobuf::Field::FieldArray[SignalExternalWorkflowExecutionFailedCause, SignalExternalWorkflowExecutionFailedCause | values]

      # The type of `map` field.
      type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, SignalExternalWorkflowExecutionFailedCause, SignalExternalWorkflowExecutionFailedCause | values]

      type array = ::Array[SignalExternalWorkflowExecutionFailedCause | values]

      type hash[KEY] = ::Hash[KEY, SignalExternalWorkflowExecutionFailedCause | values]
    end

    # Used as arguments to activities, signals, queries, etc.
    #
    class Payload < ::Protobuf::Message
      attr_accessor metadata(): ::Protobuf::field_hash[::String, ::String]

      def metadata=: (::Hash[::String, ::String]) -> ::Hash[::String, ::String]
                   | ...

      def metadata!: () -> ::Protobuf::field_hash[::String, ::String]?

      attr_accessor data(): ::String

      def data!: () -> ::String?

      def initialize: (?metadata: ::Hash[::String, ::String], ?data: ::String) -> void

      def []: (:metadata) -> ::Protobuf::field_hash[::String, ::String]
            | (:data) -> ::String
            | (::Symbol) -> untyped

      def []=: (:metadata, ::Protobuf::field_hash[::String, ::String]) -> ::Protobuf::field_hash[::String, ::String]
             | (:metadata, ::Hash[::String, ::String]) -> ::Hash[::String, ::String]
             | (:data, ::String) -> ::String
             | (::Symbol, untyped) -> untyped

      interface _ToProto
        def to_proto: () -> Payload
      end

      # The type of `#initialize` parameter.
      type init = Payload | _ToProto

      # The type of `repeated` field.
      type field_array = ::Protobuf::Field::FieldArray[Payload, Payload | _ToProto]

      # The type of `map` field.
      type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, Payload, Payload | _ToProto]

      type array = ::Array[Payload | _ToProto]

      type hash[KEY] = ::Hash[KEY, Payload | _ToProto]
    end

    # Identifying information about a particular workflow execution. Namespace is expected to be
    #  assumed or included in whatever message is wrapping this one.
    #
    class WorkflowExecution < ::Protobuf::Message
      # Can never be empty
      #
      attr_accessor workflow_id(): ::String

      def workflow_id!: () -> ::String?

      # May be empty if the most recent run of the workflow with the given ID is being targeted
      #
      attr_accessor run_id(): ::String

      def run_id!: () -> ::String?

      def initialize: (?workflow_id: ::String, ?run_id: ::String) -> void

      def []: (:workflow_id) -> ::String
            | (:run_id) -> ::String
            | (::Symbol) -> untyped

      def []=: (:workflow_id, ::String) -> ::String
             | (:run_id, ::String) -> ::String
             | (::Symbol, untyped) -> untyped

      interface _ToProto
        def to_proto: () -> WorkflowExecution
      end

      # The type of `#initialize` parameter.
      type init = WorkflowExecution | _ToProto

      # The type of `repeated` field.
      type field_array = ::Protobuf::Field::FieldArray[WorkflowExecution, WorkflowExecution | _ToProto]

      # The type of `map` field.
      type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, WorkflowExecution, WorkflowExecution | _ToProto]

      type array = ::Array[WorkflowExecution | _ToProto]

      type hash[KEY] = ::Hash[KEY, WorkflowExecution | _ToProto]
    end

    # Identifying information about a particular workflow execution, including namespace
    #
    class NamespacedWorkflowExecution < ::Protobuf::Message
      # Namespace the workflow run is located in
      #
      attr_accessor namespace(): ::String

      def namespace!: () -> ::String?

      # Can never be empty
      #
      attr_accessor workflow_id(): ::String

      def workflow_id!: () -> ::String?

      # May be empty if the most recent run of the workflow with the given ID is being targeted
      #
      attr_accessor run_id(): ::String

      def run_id!: () -> ::String?

      def initialize: (?namespace: ::String, ?workflow_id: ::String, ?run_id: ::String) -> void

      def []: (:namespace) -> ::String
            | (:workflow_id) -> ::String
            | (:run_id) -> ::String
            | (::Symbol) -> untyped

      def []=: (:namespace, ::String) -> ::String
             | (:workflow_id, ::String) -> ::String
             | (:run_id, ::String) -> ::String
             | (::Symbol, untyped) -> untyped

      interface _ToProto
        def to_proto: () -> NamespacedWorkflowExecution
      end

      # The type of `#initialize` parameter.
      type init = NamespacedWorkflowExecution | _ToProto

      # The type of `repeated` field.
      type field_array = ::Protobuf::Field::FieldArray[NamespacedWorkflowExecution, NamespacedWorkflowExecution | _ToProto]

      # The type of `map` field.
      type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, NamespacedWorkflowExecution, NamespacedWorkflowExecution | _ToProto]

      type array = ::Array[NamespacedWorkflowExecution | _ToProto]

      type hash[KEY] = ::Hash[KEY, NamespacedWorkflowExecution | _ToProto]
    end

    # Defines how an activity or workflow should be retried in the event of failure, timeout, etc.
    #  Defaults may differ depending on what this is being used for. See containing messages.
    #
    class RetryPolicy < ::Protobuf::Message
      # Interval of the first retry. If backoff_coefficient is 1.0 then it is used for all
      #  retries. If this is not specified, there will be *no retrying*. Lang SDKs should require
      #  this to be set.
      #
      attr_accessor initial_interval(): ::Google::Protobuf::Duration?

      # Interval of the first retry. If backoff_coefficient is 1.0 then it is used for all
      #  retries. If this is not specified, there will be *no retrying*. Lang SDKs should require
      #  this to be set.
      #
      def initial_interval=: [M < ::Google::Protobuf::Duration::_ToProto] (M?) -> M?
                           | ...

      def initial_interval!: () -> ::Google::Protobuf::Duration?

      # Coefficient used to calculate the next retry interval. The next retry interval is previous
      #  interval multiplied by the coefficient. Must be 1 or larger.
      #
      attr_accessor backoff_coefficient(): ::Float

      def backoff_coefficient!: () -> ::Float?

      # Maximum interval between retries. Exponential backoff leads to interval increase. This value
      #  caps that interval.
      #
      attr_accessor maximum_interval(): ::Google::Protobuf::Duration?

      # Maximum interval between retries. Exponential backoff leads to interval increase. This value
      #  caps that interval.
      #
      def maximum_interval=: [M < ::Google::Protobuf::Duration::_ToProto] (M?) -> M?
                           | ...

      def maximum_interval!: () -> ::Google::Protobuf::Duration?

      # Maximum number of attempts. When exceeded, retrying will stop. 1 disables retries. 0 means
      #  unlimited retries (until the activity or workflow's total timeout is reached).
      #
      attr_accessor maximum_attempts(): ::Integer

      def maximum_attempts!: () -> ::Integer?

      # If a stringified error type matches something in this list, retries will cease.
      #
      attr_accessor non_retryable_error_types(): ::Protobuf::field_array[::String]

      # If a stringified error type matches something in this list, retries will cease.
      #
      def non_retryable_error_types=: (::Array[::String]) -> ::Array[::String]
                                    | ...

      def non_retryable_error_types!: () -> ::Protobuf::field_array[::String]?

      def initialize: (?initial_interval: ::Google::Protobuf::Duration::init?, ?backoff_coefficient: ::Float, ?maximum_interval: ::Google::Protobuf::Duration::init?, ?maximum_attempts: ::Integer, ?non_retryable_error_types: ::Array[::String]) -> void

      def []: (:initial_interval) -> ::Google::Protobuf::Duration?
            | (:backoff_coefficient) -> ::Float
            | (:maximum_interval) -> ::Google::Protobuf::Duration?
            | (:maximum_attempts) -> ::Integer
            | (:non_retryable_error_types) -> ::Protobuf::field_array[::String]
            | (::Symbol) -> untyped

      def []=: (:initial_interval, ::Google::Protobuf::Duration?) -> ::Google::Protobuf::Duration?
             | [M < ::Google::Protobuf::Duration::_ToProto] (:initial_interval, M?) -> M?
             | (:backoff_coefficient, ::Float) -> ::Float
             | (:maximum_interval, ::Google::Protobuf::Duration?) -> ::Google::Protobuf::Duration?
             | [M < ::Google::Protobuf::Duration::_ToProto] (:maximum_interval, M?) -> M?
             | (:maximum_attempts, ::Integer) -> ::Integer
             | (:non_retryable_error_types, ::Protobuf::field_array[::String]) -> ::Protobuf::field_array[::String]
             | (:non_retryable_error_types, ::Array[::String]) -> ::Array[::String]
             | (::Symbol, untyped) -> untyped

      interface _ToProto
        def to_proto: () -> RetryPolicy
      end

      # The type of `#initialize` parameter.
      type init = RetryPolicy | _ToProto

      # The type of `repeated` field.
      type field_array = ::Protobuf::Field::FieldArray[RetryPolicy, RetryPolicy | _ToProto]

      # The type of `map` field.
      type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, RetryPolicy, RetryPolicy | _ToProto]

      type array = ::Array[RetryPolicy | _ToProto]

      type hash[KEY] = ::Hash[KEY, RetryPolicy | _ToProto]
    end
  end
end
