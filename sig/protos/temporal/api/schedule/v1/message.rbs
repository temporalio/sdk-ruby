module Temporalio
  module Api
    module Schedule
      module V1
        # CalendarSpec describes an event specification relative to the calendar,
        #  similar to a traditional cron specification, but with labeled fields. Each
        #  field can be one of:
        #    *: matches always
        #    x: matches when the field equals x
        #    x/y : matches when the field equals x+n*y where n is an integer
        #    x-z: matches when the field is between x and z inclusive
        #    w,x,y,...: matches when the field is one of the listed values
        #  Each x, y, z, ... is either a decimal integer, or a month or day of week name
        #  or abbreviation (in the appropriate fields).
        #  A timestamp matches if all fields match.
        #  Note that fields have different default values, for convenience.
        #  Note that the special case that some cron implementations have for treating
        #  day_of_month and day_of_week as "or" instead of "and" when both are set is
        #  not implemented.
        #  day_of_week can accept 0 or 7 as Sunday
        #  CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
        #  returned if you describe the schedule.
        #
        class CalendarSpec < ::Protobuf::Message
          # Expression to match seconds. Default: 0
          #
          attr_accessor second(): ::String

          def second!: () -> ::String?

          # Expression to match minutes. Default: 0
          #
          attr_accessor minute(): ::String

          def minute!: () -> ::String?

          # Expression to match hours. Default: 0
          #
          attr_accessor hour(): ::String

          def hour!: () -> ::String?

          # Expression to match days of the month. Default: *
          #  (-- api-linter: core::0140::prepositions=disabled
          #      aip.dev/not-precedent: standard name of field --)
          #
          attr_accessor day_of_month(): ::String

          def day_of_month!: () -> ::String?

          # Expression to match months. Default: *
          #
          attr_accessor month(): ::String

          def month!: () -> ::String?

          # Expression to match years. Default: *
          #
          attr_accessor year(): ::String

          def year!: () -> ::String?

          # Expression to match days of the week. Default: *
          #
          attr_accessor day_of_week(): ::String

          def day_of_week!: () -> ::String?

          # Free-form comment describing the intention of this spec.
          #
          attr_accessor comment(): ::String

          def comment!: () -> ::String?

          def initialize: (?second: ::String, ?minute: ::String, ?hour: ::String, ?day_of_month: ::String, ?month: ::String, ?year: ::String, ?day_of_week: ::String, ?comment: ::String) -> void

          def []: (:second) -> ::String
                | (:minute) -> ::String
                | (:hour) -> ::String
                | (:day_of_month) -> ::String
                | (:month) -> ::String
                | (:year) -> ::String
                | (:day_of_week) -> ::String
                | (:comment) -> ::String
                | (::Symbol) -> untyped

          def []=: (:second, ::String) -> ::String
                 | (:minute, ::String) -> ::String
                 | (:hour, ::String) -> ::String
                 | (:day_of_month, ::String) -> ::String
                 | (:month, ::String) -> ::String
                 | (:year, ::String) -> ::String
                 | (:day_of_week, ::String) -> ::String
                 | (:comment, ::String) -> ::String
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> CalendarSpec
          end

          # The type of `#initialize` parameter.
          type init = CalendarSpec | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[CalendarSpec, CalendarSpec | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, CalendarSpec, CalendarSpec | _ToProto]

          type array = ::Array[CalendarSpec | _ToProto]

          type hash[KEY] = ::Hash[KEY, CalendarSpec | _ToProto]
        end

        # Range represents a set of integer values, used to match fields of a calendar
        #  time in StructuredCalendarSpec. If end < start, then end is interpreted as
        #  equal to start. This means you can use a Range with start set to a value, and
        #  end and step unset (defaulting to 0) to represent a single value.
        #
        class Range < ::Protobuf::Message
          # Start of range (inclusive).
          #
          attr_accessor start(): ::Integer

          def start!: () -> ::Integer?

          # End of range (inclusive).
          #
          attr_accessor end(): ::Integer

          def end!: () -> ::Integer?

          # Step (optional, default 1).
          #
          attr_accessor step(): ::Integer

          def step!: () -> ::Integer?

          def initialize: (?start: ::Integer, ?end: ::Integer, ?step: ::Integer) -> void

          def []: (:start) -> ::Integer
                | (:end) -> ::Integer
                | (:step) -> ::Integer
                | (::Symbol) -> untyped

          def []=: (:start, ::Integer) -> ::Integer
                 | (:end, ::Integer) -> ::Integer
                 | (:step, ::Integer) -> ::Integer
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> Range
          end

          # The type of `#initialize` parameter.
          type init = Range | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[Range, Range | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, Range, Range | _ToProto]

          type array = ::Array[Range | _ToProto]

          type hash[KEY] = ::Hash[KEY, Range | _ToProto]
        end

        # StructuredCalendarSpec describes an event specification relative to the
        #  calendar, in a form that's easy to work with programmatically. Each field can
        #  be one or more ranges.
        #  A timestamp matches if at least one range of each field matches the
        #  corresponding fields of the timestamp, except for year: if year is missing,
        #  that means all years match. For all fields besides year, at least one Range
        #  must be present to match anything.
        #  TODO: add relative-to-end-of-month
        #  TODO: add nth day-of-week in month
        #
        class StructuredCalendarSpec < ::Protobuf::Message
          # Match seconds (0-59)
          #
          attr_accessor second(): ::Temporalio::Api::Schedule::V1::Range::field_array

          # Match seconds (0-59)
          #
          def second=: (::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                     | ...

          def second!: () -> ::Temporalio::Api::Schedule::V1::Range::field_array?

          # Match minutes (0-59)
          #
          attr_accessor minute(): ::Temporalio::Api::Schedule::V1::Range::field_array

          # Match minutes (0-59)
          #
          def minute=: (::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                     | ...

          def minute!: () -> ::Temporalio::Api::Schedule::V1::Range::field_array?

          # Match hours (0-23)
          #
          attr_accessor hour(): ::Temporalio::Api::Schedule::V1::Range::field_array

          # Match hours (0-23)
          #
          def hour=: (::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                   | ...

          def hour!: () -> ::Temporalio::Api::Schedule::V1::Range::field_array?

          # Match days of the month (1-31)
          #  (-- api-linter: core::0140::prepositions=disabled
          #      aip.dev/not-precedent: standard name of field --)
          #
          attr_accessor day_of_month(): ::Temporalio::Api::Schedule::V1::Range::field_array

          # Match days of the month (1-31)
          #  (-- api-linter: core::0140::prepositions=disabled
          #      aip.dev/not-precedent: standard name of field --)
          #
          def day_of_month=: (::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                           | ...

          def day_of_month!: () -> ::Temporalio::Api::Schedule::V1::Range::field_array?

          # Match months (1-12)
          #
          attr_accessor month(): ::Temporalio::Api::Schedule::V1::Range::field_array

          # Match months (1-12)
          #
          def month=: (::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                    | ...

          def month!: () -> ::Temporalio::Api::Schedule::V1::Range::field_array?

          # Match years.
          #
          attr_accessor year(): ::Temporalio::Api::Schedule::V1::Range::field_array

          # Match years.
          #
          def year=: (::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                   | ...

          def year!: () -> ::Temporalio::Api::Schedule::V1::Range::field_array?

          # Match days of the week (0-6; 0 is Sunday).
          #
          attr_accessor day_of_week(): ::Temporalio::Api::Schedule::V1::Range::field_array

          # Match days of the week (0-6; 0 is Sunday).
          #
          def day_of_week=: (::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                          | ...

          def day_of_week!: () -> ::Temporalio::Api::Schedule::V1::Range::field_array?

          # Free-form comment describing the intention of this spec.
          #
          attr_accessor comment(): ::String

          def comment!: () -> ::String?

          def initialize: (?second: ::Temporalio::Api::Schedule::V1::Range::array, ?minute: ::Temporalio::Api::Schedule::V1::Range::array, ?hour: ::Temporalio::Api::Schedule::V1::Range::array, ?day_of_month: ::Temporalio::Api::Schedule::V1::Range::array, ?month: ::Temporalio::Api::Schedule::V1::Range::array, ?year: ::Temporalio::Api::Schedule::V1::Range::array, ?day_of_week: ::Temporalio::Api::Schedule::V1::Range::array, ?comment: ::String) -> void

          def []: (:second) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                | (:minute) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                | (:hour) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                | (:day_of_month) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                | (:month) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                | (:year) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                | (:day_of_week) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                | (:comment) -> ::String
                | (::Symbol) -> untyped

          def []=: (:second, ::Temporalio::Api::Schedule::V1::Range::field_array) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                 | (:second, ::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                 | (:minute, ::Temporalio::Api::Schedule::V1::Range::field_array) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                 | (:minute, ::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                 | (:hour, ::Temporalio::Api::Schedule::V1::Range::field_array) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                 | (:hour, ::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                 | (:day_of_month, ::Temporalio::Api::Schedule::V1::Range::field_array) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                 | (:day_of_month, ::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                 | (:month, ::Temporalio::Api::Schedule::V1::Range::field_array) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                 | (:month, ::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                 | (:year, ::Temporalio::Api::Schedule::V1::Range::field_array) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                 | (:year, ::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                 | (:day_of_week, ::Temporalio::Api::Schedule::V1::Range::field_array) -> ::Temporalio::Api::Schedule::V1::Range::field_array
                 | (:day_of_week, ::Temporalio::Api::Schedule::V1::Range::array) -> ::Temporalio::Api::Schedule::V1::Range::array
                 | (:comment, ::String) -> ::String
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> StructuredCalendarSpec
          end

          # The type of `#initialize` parameter.
          type init = StructuredCalendarSpec | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[StructuredCalendarSpec, StructuredCalendarSpec | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, StructuredCalendarSpec, StructuredCalendarSpec | _ToProto]

          type array = ::Array[StructuredCalendarSpec | _ToProto]

          type hash[KEY] = ::Hash[KEY, StructuredCalendarSpec | _ToProto]
        end

        # IntervalSpec matches times that can be expressed as:
        #  epoch + n * interval + phase
        #  where n is an integer.
        #  phase defaults to zero if missing. interval is required.
        #  Both interval and phase must be non-negative and are truncated to the nearest
        #  second before any calculations.
        #  For example, an interval of 1 hour with phase of zero would match every hour,
        #  on the hour. The same interval but a phase of 19 minutes would match every
        #  xx:19:00. An interval of 28 days with phase zero would match
        #  2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
        #  days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
        #
        class IntervalSpec < ::Protobuf::Message
          attr_accessor interval(): ::Google::Protobuf::Duration?

          def interval=: [M < ::Google::Protobuf::Duration::_ToProto] (M?) -> M?
                       | ...

          def interval!: () -> ::Google::Protobuf::Duration?

          attr_accessor phase(): ::Google::Protobuf::Duration?

          def phase=: [M < ::Google::Protobuf::Duration::_ToProto] (M?) -> M?
                    | ...

          def phase!: () -> ::Google::Protobuf::Duration?

          def initialize: (?interval: ::Google::Protobuf::Duration::init?, ?phase: ::Google::Protobuf::Duration::init?) -> void

          def []: (:interval) -> ::Google::Protobuf::Duration?
                | (:phase) -> ::Google::Protobuf::Duration?
                | (::Symbol) -> untyped

          def []=: (:interval, ::Google::Protobuf::Duration?) -> ::Google::Protobuf::Duration?
                 | [M < ::Google::Protobuf::Duration::_ToProto] (:interval, M?) -> M?
                 | (:phase, ::Google::Protobuf::Duration?) -> ::Google::Protobuf::Duration?
                 | [M < ::Google::Protobuf::Duration::_ToProto] (:phase, M?) -> M?
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> IntervalSpec
          end

          # The type of `#initialize` parameter.
          type init = IntervalSpec | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[IntervalSpec, IntervalSpec | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, IntervalSpec, IntervalSpec | _ToProto]

          type array = ::Array[IntervalSpec | _ToProto]

          type hash[KEY] = ::Hash[KEY, IntervalSpec | _ToProto]
        end

        # ScheduleSpec is a complete description of a set of absolute timestamps
        #  (possibly infinite) that an action should occur at. The meaning of a
        #  ScheduleSpec depends only on its contents and never changes, except that the
        #  definition of a time zone can change over time (most commonly, when daylight
        #  saving time policy changes for an area). To create a totally self-contained
        #  ScheduleSpec, use UTC or include timezone_data.
        #
        #  For input, you can provide zero or more of: structured_calendar, calendar,
        #  cron_string, interval, and exclude_structured_calendar, and all of them will
        #  be used (the schedule will take action at the union of all of their times,
        #  minus the ones that match exclude_structured_calendar).
        #
        #  On input, calendar and cron_string fields will be compiled into
        #  structured_calendar (and maybe interval and timezone_name), so if you
        #  Describe a schedule, you'll see only structured_calendar, interval, etc.
        #
        class ScheduleSpec < ::Protobuf::Message
          # Calendar-based specifications of times.
          #
          attr_accessor structured_calendar(): ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::field_array

          # Calendar-based specifications of times.
          #
          def structured_calendar=: (::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::array) -> ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::array
                                  | ...

          def structured_calendar!: () -> ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::field_array?

          # cron_string holds a traditional cron specification as a string. It
          #  accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
          #  same way as CalendarSpec.
          #  5 fields:         minute, hour, day_of_month, month, day_of_week
          #  6 fields:         minute, hour, day_of_month, month, day_of_week, year
          #  7 fields: second, minute, hour, day_of_month, month, day_of_week, year
          #  If year is not given, it defaults to *. If second is not given, it
          #  defaults to 0.
          #  Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
          #  accepted instead of the 5-7 time fields.
          #  Optionally, the string can be preceded by CRON_TZ=<timezone name> or
          #  TZ=<timezone name>, which will get copied to timezone_name. (There must
          #  not also be a timezone_name present.)
          #  Optionally "#" followed by a comment can appear at the end of the string.
          #  Note that the special case that some cron implementations have for
          #  treating day_of_month and day_of_week as "or" instead of "and" when both
          #  are set is not implemented.
          #  @every <interval>[/<phase>] is accepted and gets compiled into an
          #  IntervalSpec instead. <interval> and <phase> should be a decimal integer
          #  with a unit suffix s, m, h, or d.
          #
          attr_accessor cron_string(): ::Protobuf::field_array[::String]

          # cron_string holds a traditional cron specification as a string. It
          #  accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
          #  same way as CalendarSpec.
          #  5 fields:         minute, hour, day_of_month, month, day_of_week
          #  6 fields:         minute, hour, day_of_month, month, day_of_week, year
          #  7 fields: second, minute, hour, day_of_month, month, day_of_week, year
          #  If year is not given, it defaults to *. If second is not given, it
          #  defaults to 0.
          #  Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
          #  accepted instead of the 5-7 time fields.
          #  Optionally, the string can be preceded by CRON_TZ=<timezone name> or
          #  TZ=<timezone name>, which will get copied to timezone_name. (There must
          #  not also be a timezone_name present.)
          #  Optionally "#" followed by a comment can appear at the end of the string.
          #  Note that the special case that some cron implementations have for
          #  treating day_of_month and day_of_week as "or" instead of "and" when both
          #  are set is not implemented.
          #  @every <interval>[/<phase>] is accepted and gets compiled into an
          #  IntervalSpec instead. <interval> and <phase> should be a decimal integer
          #  with a unit suffix s, m, h, or d.
          #
          def cron_string=: (::Array[::String]) -> ::Array[::String]
                          | ...

          def cron_string!: () -> ::Protobuf::field_array[::String]?

          # Calendar-based specifications of times.
          #
          attr_accessor calendar(): ::Temporalio::Api::Schedule::V1::CalendarSpec::field_array

          # Calendar-based specifications of times.
          #
          def calendar=: (::Temporalio::Api::Schedule::V1::CalendarSpec::array) -> ::Temporalio::Api::Schedule::V1::CalendarSpec::array
                       | ...

          def calendar!: () -> ::Temporalio::Api::Schedule::V1::CalendarSpec::field_array?

          # Interval-based specifications of times.
          #
          attr_accessor interval(): ::Temporalio::Api::Schedule::V1::IntervalSpec::field_array

          # Interval-based specifications of times.
          #
          def interval=: (::Temporalio::Api::Schedule::V1::IntervalSpec::array) -> ::Temporalio::Api::Schedule::V1::IntervalSpec::array
                       | ...

          def interval!: () -> ::Temporalio::Api::Schedule::V1::IntervalSpec::field_array?

          # Any timestamps matching any of exclude_* will be skipped.
          #
          # use exclude_structured_calendar
          #
          # ----
          #
          # Protobuf options:
          #
          # - `deprecated = true`
          #
          attr_accessor exclude_calendar(): ::Temporalio::Api::Schedule::V1::CalendarSpec::field_array

          # Any timestamps matching any of exclude_* will be skipped.
          #
          # use exclude_structured_calendar
          #
          # ----
          #
          # Protobuf options:
          #
          # - `deprecated = true`
          #
          def exclude_calendar=: (::Temporalio::Api::Schedule::V1::CalendarSpec::array) -> ::Temporalio::Api::Schedule::V1::CalendarSpec::array
                               | ...

          def exclude_calendar!: () -> ::Temporalio::Api::Schedule::V1::CalendarSpec::field_array?

          attr_accessor exclude_structured_calendar(): ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::field_array

          def exclude_structured_calendar=: (::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::array) -> ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::array
                                          | ...

          def exclude_structured_calendar!: () -> ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::field_array?

          # If start_time is set, any timestamps before start_time will be skipped.
          #  (Together, start_time and end_time make an inclusive interval.)
          #
          attr_accessor start_time(): ::Google::Protobuf::Timestamp?

          # If start_time is set, any timestamps before start_time will be skipped.
          #  (Together, start_time and end_time make an inclusive interval.)
          #
          def start_time=: [M < ::Google::Protobuf::Timestamp::_ToProto] (M?) -> M?
                         | ...

          def start_time!: () -> ::Google::Protobuf::Timestamp?

          # If end_time is set, any timestamps after end_time will be skipped.
          #
          attr_accessor end_time(): ::Google::Protobuf::Timestamp?

          # If end_time is set, any timestamps after end_time will be skipped.
          #
          def end_time=: [M < ::Google::Protobuf::Timestamp::_ToProto] (M?) -> M?
                       | ...

          def end_time!: () -> ::Google::Protobuf::Timestamp?

          # All timestamps will be incremented by a random value from 0 to this
          #  amount of jitter. Default: 0
          #
          attr_accessor jitter(): ::Google::Protobuf::Duration?

          # All timestamps will be incremented by a random value from 0 to this
          #  amount of jitter. Default: 0
          #
          def jitter=: [M < ::Google::Protobuf::Duration::_ToProto] (M?) -> M?
                     | ...

          def jitter!: () -> ::Google::Protobuf::Duration?

          # Time zone to interpret all calendar-based specs in.
          #
          #  If unset, defaults to UTC. We recommend using UTC for your application if
          #  at all possible, to avoid various surprising properties of time zones.
          #
          #  Time zones may be provided by name, corresponding to names in the IANA
          #  time zone database (see https://www.iana.org/time-zones). The definition
          #  will be loaded by the Temporal server from the environment it runs in.
          #
          #  If your application requires more control over the time zone definition
          #  used, it may pass in a complete definition in the form of a TZif file
          #  from the time zone database. If present, this will be used instead of
          #  loading anything from the environment. You are then responsible for
          #  updating timezone_data when the definition changes.
          #
          #  Calendar spec matching is based on literal matching of the clock time
          #  with no special handling of DST: if you write a calendar spec that fires
          #  at 2:30am and specify a time zone that follows DST, that action will not
          #  be triggered on the day that has no 2:30am. Similarly, an action that
          #  fires at 1:30am will be triggered twice on the day that has two 1:30s.
          #
          #  Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
          #
          attr_accessor timezone_name(): ::String

          def timezone_name!: () -> ::String?

          attr_accessor timezone_data(): ::String

          def timezone_data!: () -> ::String?

          def initialize: (?structured_calendar: ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::array, ?cron_string: ::Array[::String], ?calendar: ::Temporalio::Api::Schedule::V1::CalendarSpec::array, ?interval: ::Temporalio::Api::Schedule::V1::IntervalSpec::array, ?exclude_calendar: ::Temporalio::Api::Schedule::V1::CalendarSpec::array, ?exclude_structured_calendar: ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::array, ?start_time: ::Google::Protobuf::Timestamp::init?, ?end_time: ::Google::Protobuf::Timestamp::init?, ?jitter: ::Google::Protobuf::Duration::init?, ?timezone_name: ::String, ?timezone_data: ::String) -> void

          def []: (:structured_calendar) -> ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::field_array
                | (:cron_string) -> ::Protobuf::field_array[::String]
                | (:calendar) -> ::Temporalio::Api::Schedule::V1::CalendarSpec::field_array
                | (:interval) -> ::Temporalio::Api::Schedule::V1::IntervalSpec::field_array
                | (:exclude_calendar) -> ::Temporalio::Api::Schedule::V1::CalendarSpec::field_array
                | (:exclude_structured_calendar) -> ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::field_array
                | (:start_time) -> ::Google::Protobuf::Timestamp?
                | (:end_time) -> ::Google::Protobuf::Timestamp?
                | (:jitter) -> ::Google::Protobuf::Duration?
                | (:timezone_name) -> ::String
                | (:timezone_data) -> ::String
                | (::Symbol) -> untyped

          def []=: (:structured_calendar, ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::field_array) -> ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::field_array
                 | (:structured_calendar, ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::array) -> ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::array
                 | (:cron_string, ::Protobuf::field_array[::String]) -> ::Protobuf::field_array[::String]
                 | (:cron_string, ::Array[::String]) -> ::Array[::String]
                 | (:calendar, ::Temporalio::Api::Schedule::V1::CalendarSpec::field_array) -> ::Temporalio::Api::Schedule::V1::CalendarSpec::field_array
                 | (:calendar, ::Temporalio::Api::Schedule::V1::CalendarSpec::array) -> ::Temporalio::Api::Schedule::V1::CalendarSpec::array
                 | (:interval, ::Temporalio::Api::Schedule::V1::IntervalSpec::field_array) -> ::Temporalio::Api::Schedule::V1::IntervalSpec::field_array
                 | (:interval, ::Temporalio::Api::Schedule::V1::IntervalSpec::array) -> ::Temporalio::Api::Schedule::V1::IntervalSpec::array
                 | (:exclude_calendar, ::Temporalio::Api::Schedule::V1::CalendarSpec::field_array) -> ::Temporalio::Api::Schedule::V1::CalendarSpec::field_array
                 | (:exclude_calendar, ::Temporalio::Api::Schedule::V1::CalendarSpec::array) -> ::Temporalio::Api::Schedule::V1::CalendarSpec::array
                 | (:exclude_structured_calendar, ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::field_array) -> ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::field_array
                 | (:exclude_structured_calendar, ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::array) -> ::Temporalio::Api::Schedule::V1::StructuredCalendarSpec::array
                 | (:start_time, ::Google::Protobuf::Timestamp?) -> ::Google::Protobuf::Timestamp?
                 | [M < ::Google::Protobuf::Timestamp::_ToProto] (:start_time, M?) -> M?
                 | (:end_time, ::Google::Protobuf::Timestamp?) -> ::Google::Protobuf::Timestamp?
                 | [M < ::Google::Protobuf::Timestamp::_ToProto] (:end_time, M?) -> M?
                 | (:jitter, ::Google::Protobuf::Duration?) -> ::Google::Protobuf::Duration?
                 | [M < ::Google::Protobuf::Duration::_ToProto] (:jitter, M?) -> M?
                 | (:timezone_name, ::String) -> ::String
                 | (:timezone_data, ::String) -> ::String
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> ScheduleSpec
          end

          # The type of `#initialize` parameter.
          type init = ScheduleSpec | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[ScheduleSpec, ScheduleSpec | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, ScheduleSpec, ScheduleSpec | _ToProto]

          type array = ::Array[ScheduleSpec | _ToProto]

          type hash[KEY] = ::Hash[KEY, ScheduleSpec | _ToProto]
        end

        class SchedulePolicies < ::Protobuf::Message
          # Policy for overlaps.
          #  Note that this can be changed after a schedule has taken some actions,
          #  and some changes might produce unintuitive results. In general, the later
          #  policy overrides the earlier policy.
          #
          attr_accessor overlap_policy(): ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy

          # Policy for overlaps.
          #  Note that this can be changed after a schedule has taken some actions,
          #  and some changes might produce unintuitive results. In general, the later
          #  policy overrides the earlier policy.
          #
          def overlap_policy=: (::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values
                             | ...

          def overlap_policy!: () -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy?

          # Policy for catchups:
          #  If the Temporal server misses an action due to one or more components
          #  being down, and comes back up, the action will be run if the scheduled
          #  time is within this window from the current time.
          #  This value defaults to 60 seconds, and can't be less than 10 seconds.
          #
          attr_accessor catchup_window(): ::Google::Protobuf::Duration?

          # Policy for catchups:
          #  If the Temporal server misses an action due to one or more components
          #  being down, and comes back up, the action will be run if the scheduled
          #  time is within this window from the current time.
          #  This value defaults to 60 seconds, and can't be less than 10 seconds.
          #
          def catchup_window=: [M < ::Google::Protobuf::Duration::_ToProto] (M?) -> M?
                             | ...

          def catchup_window!: () -> ::Google::Protobuf::Duration?

          # If true, and a workflow run fails or times out, turn on "paused".
          #  This applies after retry policies: the full chain of retries must fail to
          #  trigger a pause here.
          #
          attr_accessor pause_on_failure(): bool

          def pause_on_failure!: () -> bool?

          def initialize: (?overlap_policy: ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::init, ?catchup_window: ::Google::Protobuf::Duration::init?, ?pause_on_failure: bool) -> void

          def []: (:overlap_policy) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy
                | (:catchup_window) -> ::Google::Protobuf::Duration?
                | (:pause_on_failure) -> bool
                | (::Symbol) -> untyped

          def []=: (:overlap_policy, ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy
                 | (:overlap_policy, ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values
                 | (:catchup_window, ::Google::Protobuf::Duration?) -> ::Google::Protobuf::Duration?
                 | [M < ::Google::Protobuf::Duration::_ToProto] (:catchup_window, M?) -> M?
                 | (:pause_on_failure, bool) -> bool
                 | (::Symbol, untyped) -> untyped

          def pause_on_failure?: () -> bool

          interface _ToProto
            def to_proto: () -> SchedulePolicies
          end

          # The type of `#initialize` parameter.
          type init = SchedulePolicies | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[SchedulePolicies, SchedulePolicies | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, SchedulePolicies, SchedulePolicies | _ToProto]

          type array = ::Array[SchedulePolicies | _ToProto]

          type hash[KEY] = ::Hash[KEY, SchedulePolicies | _ToProto]
        end

        class ScheduleAction < ::Protobuf::Message
          # All fields of NewWorkflowExecutionInfo are valid except for:
          #  - workflow_id_reuse_policy
          #  - cron_schedule
          #  The workflow id of the started workflow may not match this exactly,
          #  it may have a timestamp appended for uniqueness.
          #
          attr_accessor start_workflow(): ::Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo?

          # All fields of NewWorkflowExecutionInfo are valid except for:
          #  - workflow_id_reuse_policy
          #  - cron_schedule
          #  The workflow id of the started workflow may not match this exactly,
          #  it may have a timestamp appended for uniqueness.
          #
          def start_workflow=: [M < ::Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo::_ToProto] (M?) -> M?
                             | ...

          def start_workflow!: () -> ::Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo?

          def initialize: (?start_workflow: ::Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo::init?) -> void

          def []: (:start_workflow) -> ::Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo?
                | (::Symbol) -> untyped

          def []=: (:start_workflow, ::Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo?) -> ::Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo?
                 | [M < ::Temporalio::Api::Workflow::V1::NewWorkflowExecutionInfo::_ToProto] (:start_workflow, M?) -> M?
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> ScheduleAction
          end

          # The type of `#initialize` parameter.
          type init = ScheduleAction | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[ScheduleAction, ScheduleAction | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, ScheduleAction, ScheduleAction | _ToProto]

          type array = ::Array[ScheduleAction | _ToProto]

          type hash[KEY] = ::Hash[KEY, ScheduleAction | _ToProto]
        end

        class ScheduleActionResult < ::Protobuf::Message
          # Time that the action was taken (according to the schedule, including jitter).
          #
          attr_accessor schedule_time(): ::Google::Protobuf::Timestamp?

          # Time that the action was taken (according to the schedule, including jitter).
          #
          def schedule_time=: [M < ::Google::Protobuf::Timestamp::_ToProto] (M?) -> M?
                            | ...

          def schedule_time!: () -> ::Google::Protobuf::Timestamp?

          # Time that the action was taken (real time).
          #
          attr_accessor actual_time(): ::Google::Protobuf::Timestamp?

          # Time that the action was taken (real time).
          #
          def actual_time=: [M < ::Google::Protobuf::Timestamp::_ToProto] (M?) -> M?
                          | ...

          def actual_time!: () -> ::Google::Protobuf::Timestamp?

          # If action was start_workflow:
          #
          attr_accessor start_workflow_result(): ::Temporalio::Api::Common::V1::WorkflowExecution?

          # If action was start_workflow:
          #
          def start_workflow_result=: [M < ::Temporalio::Api::Common::V1::WorkflowExecution::_ToProto] (M?) -> M?
                                    | ...

          def start_workflow_result!: () -> ::Temporalio::Api::Common::V1::WorkflowExecution?

          def initialize: (?schedule_time: ::Google::Protobuf::Timestamp::init?, ?actual_time: ::Google::Protobuf::Timestamp::init?, ?start_workflow_result: ::Temporalio::Api::Common::V1::WorkflowExecution::init?) -> void

          def []: (:schedule_time) -> ::Google::Protobuf::Timestamp?
                | (:actual_time) -> ::Google::Protobuf::Timestamp?
                | (:start_workflow_result) -> ::Temporalio::Api::Common::V1::WorkflowExecution?
                | (::Symbol) -> untyped

          def []=: (:schedule_time, ::Google::Protobuf::Timestamp?) -> ::Google::Protobuf::Timestamp?
                 | [M < ::Google::Protobuf::Timestamp::_ToProto] (:schedule_time, M?) -> M?
                 | (:actual_time, ::Google::Protobuf::Timestamp?) -> ::Google::Protobuf::Timestamp?
                 | [M < ::Google::Protobuf::Timestamp::_ToProto] (:actual_time, M?) -> M?
                 | (:start_workflow_result, ::Temporalio::Api::Common::V1::WorkflowExecution?) -> ::Temporalio::Api::Common::V1::WorkflowExecution?
                 | [M < ::Temporalio::Api::Common::V1::WorkflowExecution::_ToProto] (:start_workflow_result, M?) -> M?
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> ScheduleActionResult
          end

          # The type of `#initialize` parameter.
          type init = ScheduleActionResult | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[ScheduleActionResult, ScheduleActionResult | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, ScheduleActionResult, ScheduleActionResult | _ToProto]

          type array = ::Array[ScheduleActionResult | _ToProto]

          type hash[KEY] = ::Hash[KEY, ScheduleActionResult | _ToProto]
        end

        class ScheduleState < ::Protobuf::Message
          # Informative human-readable message with contextual notes, e.g. the reason
          #  a schedule is paused. The system may overwrite this message on certain
          #  conditions, e.g. when pause-on-failure happens.
          #
          attr_accessor notes(): ::String

          def notes!: () -> ::String?

          # If true, do not take any actions based on the schedule spec.
          #
          attr_accessor paused(): bool

          def paused!: () -> bool?

          # If limited_actions is true, decrement remaining_actions after each
          #  action, and do not take any more scheduled actions if remaining_actions
          #  is zero. Actions may still be taken by explicit request (i.e. trigger
          #  immediately or backfill). Skipped actions (due to overlap policy) do not
          #  count against remaining actions.
          #
          attr_accessor limited_actions(): bool

          def limited_actions!: () -> bool?

          attr_accessor remaining_actions(): ::Integer

          def remaining_actions!: () -> ::Integer?

          def initialize: (?notes: ::String, ?paused: bool, ?limited_actions: bool, ?remaining_actions: ::Integer) -> void

          def []: (:notes) -> ::String
                | (:paused) -> bool
                | (:limited_actions) -> bool
                | (:remaining_actions) -> ::Integer
                | (::Symbol) -> untyped

          def []=: (:notes, ::String) -> ::String
                 | (:paused, bool) -> bool
                 | (:limited_actions, bool) -> bool
                 | (:remaining_actions, ::Integer) -> ::Integer
                 | (::Symbol, untyped) -> untyped

          def paused?: () -> bool

          def limited_actions?: () -> bool

          interface _ToProto
            def to_proto: () -> ScheduleState
          end

          # The type of `#initialize` parameter.
          type init = ScheduleState | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[ScheduleState, ScheduleState | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, ScheduleState, ScheduleState | _ToProto]

          type array = ::Array[ScheduleState | _ToProto]

          type hash[KEY] = ::Hash[KEY, ScheduleState | _ToProto]
        end

        class TriggerImmediatelyRequest < ::Protobuf::Message
          # Override overlap policy for this one request.
          #
          attr_accessor overlap_policy(): ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy

          # Override overlap policy for this one request.
          #
          def overlap_policy=: (::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values
                             | ...

          def overlap_policy!: () -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy?

          def initialize: (?overlap_policy: ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::init) -> void

          def []: (:overlap_policy) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy
                | (::Symbol) -> untyped

          def []=: (:overlap_policy, ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy
                 | (:overlap_policy, ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> TriggerImmediatelyRequest
          end

          # The type of `#initialize` parameter.
          type init = TriggerImmediatelyRequest | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[TriggerImmediatelyRequest, TriggerImmediatelyRequest | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, TriggerImmediatelyRequest, TriggerImmediatelyRequest | _ToProto]

          type array = ::Array[TriggerImmediatelyRequest | _ToProto]

          type hash[KEY] = ::Hash[KEY, TriggerImmediatelyRequest | _ToProto]
        end

        class BackfillRequest < ::Protobuf::Message
          # Time range to evaluate schedule in.
          #
          attr_accessor start_time(): ::Google::Protobuf::Timestamp?

          # Time range to evaluate schedule in.
          #
          def start_time=: [M < ::Google::Protobuf::Timestamp::_ToProto] (M?) -> M?
                         | ...

          def start_time!: () -> ::Google::Protobuf::Timestamp?

          attr_accessor end_time(): ::Google::Protobuf::Timestamp?

          def end_time=: [M < ::Google::Protobuf::Timestamp::_ToProto] (M?) -> M?
                       | ...

          def end_time!: () -> ::Google::Protobuf::Timestamp?

          # Override overlap policy for this request.
          #
          attr_accessor overlap_policy(): ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy

          # Override overlap policy for this request.
          #
          def overlap_policy=: (::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values
                             | ...

          def overlap_policy!: () -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy?

          def initialize: (?start_time: ::Google::Protobuf::Timestamp::init?, ?end_time: ::Google::Protobuf::Timestamp::init?, ?overlap_policy: ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::init) -> void

          def []: (:start_time) -> ::Google::Protobuf::Timestamp?
                | (:end_time) -> ::Google::Protobuf::Timestamp?
                | (:overlap_policy) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy
                | (::Symbol) -> untyped

          def []=: (:start_time, ::Google::Protobuf::Timestamp?) -> ::Google::Protobuf::Timestamp?
                 | [M < ::Google::Protobuf::Timestamp::_ToProto] (:start_time, M?) -> M?
                 | (:end_time, ::Google::Protobuf::Timestamp?) -> ::Google::Protobuf::Timestamp?
                 | [M < ::Google::Protobuf::Timestamp::_ToProto] (:end_time, M?) -> M?
                 | (:overlap_policy, ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy
                 | (:overlap_policy, ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values) -> ::Temporalio::Api::Enums::V1::ScheduleOverlapPolicy::values
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> BackfillRequest
          end

          # The type of `#initialize` parameter.
          type init = BackfillRequest | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[BackfillRequest, BackfillRequest | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, BackfillRequest, BackfillRequest | _ToProto]

          type array = ::Array[BackfillRequest | _ToProto]

          type hash[KEY] = ::Hash[KEY, BackfillRequest | _ToProto]
        end

        class SchedulePatch < ::Protobuf::Message
          # If set, trigger one action immediately.
          #
          attr_accessor trigger_immediately(): ::Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest?

          # If set, trigger one action immediately.
          #
          def trigger_immediately=: [M < ::Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest::_ToProto] (M?) -> M?
                                  | ...

          def trigger_immediately!: () -> ::Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest?

          # If set, runs though the specified time period(s) and takes actions as if that time
          #  passed by right now, all at once. The overlap policy can be overridden for the
          #  scope of the backfill.
          #
          attr_accessor backfill_request(): ::Temporalio::Api::Schedule::V1::BackfillRequest::field_array

          # If set, runs though the specified time period(s) and takes actions as if that time
          #  passed by right now, all at once. The overlap policy can be overridden for the
          #  scope of the backfill.
          #
          def backfill_request=: (::Temporalio::Api::Schedule::V1::BackfillRequest::array) -> ::Temporalio::Api::Schedule::V1::BackfillRequest::array
                               | ...

          def backfill_request!: () -> ::Temporalio::Api::Schedule::V1::BackfillRequest::field_array?

          # If set, change the state to paused or unpaused (respectively) and set the
          #  notes field to the value of the string.
          #
          attr_accessor pause(): ::String

          def pause!: () -> ::String?

          attr_accessor unpause(): ::String

          def unpause!: () -> ::String?

          def initialize: (?trigger_immediately: ::Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest::init?, ?backfill_request: ::Temporalio::Api::Schedule::V1::BackfillRequest::array, ?pause: ::String, ?unpause: ::String) -> void

          def []: (:trigger_immediately) -> ::Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest?
                | (:backfill_request) -> ::Temporalio::Api::Schedule::V1::BackfillRequest::field_array
                | (:pause) -> ::String
                | (:unpause) -> ::String
                | (::Symbol) -> untyped

          def []=: (:trigger_immediately, ::Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest?) -> ::Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest?
                 | [M < ::Temporalio::Api::Schedule::V1::TriggerImmediatelyRequest::_ToProto] (:trigger_immediately, M?) -> M?
                 | (:backfill_request, ::Temporalio::Api::Schedule::V1::BackfillRequest::field_array) -> ::Temporalio::Api::Schedule::V1::BackfillRequest::field_array
                 | (:backfill_request, ::Temporalio::Api::Schedule::V1::BackfillRequest::array) -> ::Temporalio::Api::Schedule::V1::BackfillRequest::array
                 | (:pause, ::String) -> ::String
                 | (:unpause, ::String) -> ::String
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> SchedulePatch
          end

          # The type of `#initialize` parameter.
          type init = SchedulePatch | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[SchedulePatch, SchedulePatch | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, SchedulePatch, SchedulePatch | _ToProto]

          type array = ::Array[SchedulePatch | _ToProto]

          type hash[KEY] = ::Hash[KEY, SchedulePatch | _ToProto]
        end

        class ScheduleInfo < ::Protobuf::Message
          # Number of actions taken so far.
          #
          attr_accessor action_count(): ::Integer

          def action_count!: () -> ::Integer?

          # Number of times a scheduled action was skipped due to missing the catchup window.
          #
          attr_accessor missed_catchup_window(): ::Integer

          def missed_catchup_window!: () -> ::Integer?

          # Number of skipped actions due to overlap.
          #
          attr_accessor overlap_skipped(): ::Integer

          def overlap_skipped!: () -> ::Integer?

          # Currently-running workflows started by this schedule. (There might be
          #  more than one if the overlap policy allows overlaps.)
          #  Note that the run_ids in here are the original execution run ids as
          #  started by the schedule. If the workflows retried, did continue-as-new,
          #  or were reset, they might still be running but with a different run_id.
          #
          attr_accessor running_workflows(): ::Temporalio::Api::Common::V1::WorkflowExecution::field_array

          # Currently-running workflows started by this schedule. (There might be
          #  more than one if the overlap policy allows overlaps.)
          #  Note that the run_ids in here are the original execution run ids as
          #  started by the schedule. If the workflows retried, did continue-as-new,
          #  or were reset, they might still be running but with a different run_id.
          #
          def running_workflows=: (::Temporalio::Api::Common::V1::WorkflowExecution::array) -> ::Temporalio::Api::Common::V1::WorkflowExecution::array
                                | ...

          def running_workflows!: () -> ::Temporalio::Api::Common::V1::WorkflowExecution::field_array?

          # Most recent ten actual action times (including manual triggers).
          #
          attr_accessor recent_actions(): ::Temporalio::Api::Schedule::V1::ScheduleActionResult::field_array

          # Most recent ten actual action times (including manual triggers).
          #
          def recent_actions=: (::Temporalio::Api::Schedule::V1::ScheduleActionResult::array) -> ::Temporalio::Api::Schedule::V1::ScheduleActionResult::array
                             | ...

          def recent_actions!: () -> ::Temporalio::Api::Schedule::V1::ScheduleActionResult::field_array?

          # Next ten scheduled action times.
          #
          attr_accessor future_action_times(): ::Google::Protobuf::Timestamp::field_array

          # Next ten scheduled action times.
          #
          def future_action_times=: (::Google::Protobuf::Timestamp::array) -> ::Google::Protobuf::Timestamp::array
                                  | ...

          def future_action_times!: () -> ::Google::Protobuf::Timestamp::field_array?

          # Timestamps of schedule creation and last update.
          #
          attr_accessor create_time(): ::Google::Protobuf::Timestamp?

          # Timestamps of schedule creation and last update.
          #
          def create_time=: [M < ::Google::Protobuf::Timestamp::_ToProto] (M?) -> M?
                          | ...

          def create_time!: () -> ::Google::Protobuf::Timestamp?

          attr_accessor update_time(): ::Google::Protobuf::Timestamp?

          def update_time=: [M < ::Google::Protobuf::Timestamp::_ToProto] (M?) -> M?
                          | ...

          def update_time!: () -> ::Google::Protobuf::Timestamp?

          # Protobuf options:
          #
          # - `deprecated = true`
          #
          attr_accessor invalid_schedule_error(): ::String

          def invalid_schedule_error!: () -> ::String?

          def initialize: (?action_count: ::Integer, ?missed_catchup_window: ::Integer, ?overlap_skipped: ::Integer, ?running_workflows: ::Temporalio::Api::Common::V1::WorkflowExecution::array, ?recent_actions: ::Temporalio::Api::Schedule::V1::ScheduleActionResult::array, ?future_action_times: ::Google::Protobuf::Timestamp::array, ?create_time: ::Google::Protobuf::Timestamp::init?, ?update_time: ::Google::Protobuf::Timestamp::init?, ?invalid_schedule_error: ::String) -> void

          def []: (:action_count) -> ::Integer
                | (:missed_catchup_window) -> ::Integer
                | (:overlap_skipped) -> ::Integer
                | (:running_workflows) -> ::Temporalio::Api::Common::V1::WorkflowExecution::field_array
                | (:recent_actions) -> ::Temporalio::Api::Schedule::V1::ScheduleActionResult::field_array
                | (:future_action_times) -> ::Google::Protobuf::Timestamp::field_array
                | (:create_time) -> ::Google::Protobuf::Timestamp?
                | (:update_time) -> ::Google::Protobuf::Timestamp?
                | (:invalid_schedule_error) -> ::String
                | (::Symbol) -> untyped

          def []=: (:action_count, ::Integer) -> ::Integer
                 | (:missed_catchup_window, ::Integer) -> ::Integer
                 | (:overlap_skipped, ::Integer) -> ::Integer
                 | (:running_workflows, ::Temporalio::Api::Common::V1::WorkflowExecution::field_array) -> ::Temporalio::Api::Common::V1::WorkflowExecution::field_array
                 | (:running_workflows, ::Temporalio::Api::Common::V1::WorkflowExecution::array) -> ::Temporalio::Api::Common::V1::WorkflowExecution::array
                 | (:recent_actions, ::Temporalio::Api::Schedule::V1::ScheduleActionResult::field_array) -> ::Temporalio::Api::Schedule::V1::ScheduleActionResult::field_array
                 | (:recent_actions, ::Temporalio::Api::Schedule::V1::ScheduleActionResult::array) -> ::Temporalio::Api::Schedule::V1::ScheduleActionResult::array
                 | (:future_action_times, ::Google::Protobuf::Timestamp::field_array) -> ::Google::Protobuf::Timestamp::field_array
                 | (:future_action_times, ::Google::Protobuf::Timestamp::array) -> ::Google::Protobuf::Timestamp::array
                 | (:create_time, ::Google::Protobuf::Timestamp?) -> ::Google::Protobuf::Timestamp?
                 | [M < ::Google::Protobuf::Timestamp::_ToProto] (:create_time, M?) -> M?
                 | (:update_time, ::Google::Protobuf::Timestamp?) -> ::Google::Protobuf::Timestamp?
                 | [M < ::Google::Protobuf::Timestamp::_ToProto] (:update_time, M?) -> M?
                 | (:invalid_schedule_error, ::String) -> ::String
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> ScheduleInfo
          end

          # The type of `#initialize` parameter.
          type init = ScheduleInfo | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[ScheduleInfo, ScheduleInfo | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, ScheduleInfo, ScheduleInfo | _ToProto]

          type array = ::Array[ScheduleInfo | _ToProto]

          type hash[KEY] = ::Hash[KEY, ScheduleInfo | _ToProto]
        end

        class Schedule < ::Protobuf::Message
          attr_accessor spec(): ::Temporalio::Api::Schedule::V1::ScheduleSpec?

          def spec=: [M < ::Temporalio::Api::Schedule::V1::ScheduleSpec::_ToProto] (M?) -> M?
                   | ...

          def spec!: () -> ::Temporalio::Api::Schedule::V1::ScheduleSpec?

          attr_accessor action(): ::Temporalio::Api::Schedule::V1::ScheduleAction?

          def action=: [M < ::Temporalio::Api::Schedule::V1::ScheduleAction::_ToProto] (M?) -> M?
                     | ...

          def action!: () -> ::Temporalio::Api::Schedule::V1::ScheduleAction?

          attr_accessor policies(): ::Temporalio::Api::Schedule::V1::SchedulePolicies?

          def policies=: [M < ::Temporalio::Api::Schedule::V1::SchedulePolicies::_ToProto] (M?) -> M?
                       | ...

          def policies!: () -> ::Temporalio::Api::Schedule::V1::SchedulePolicies?

          attr_accessor state(): ::Temporalio::Api::Schedule::V1::ScheduleState?

          def state=: [M < ::Temporalio::Api::Schedule::V1::ScheduleState::_ToProto] (M?) -> M?
                    | ...

          def state!: () -> ::Temporalio::Api::Schedule::V1::ScheduleState?

          def initialize: (?spec: ::Temporalio::Api::Schedule::V1::ScheduleSpec::init?, ?action: ::Temporalio::Api::Schedule::V1::ScheduleAction::init?, ?policies: ::Temporalio::Api::Schedule::V1::SchedulePolicies::init?, ?state: ::Temporalio::Api::Schedule::V1::ScheduleState::init?) -> void

          def []: (:spec) -> ::Temporalio::Api::Schedule::V1::ScheduleSpec?
                | (:action) -> ::Temporalio::Api::Schedule::V1::ScheduleAction?
                | (:policies) -> ::Temporalio::Api::Schedule::V1::SchedulePolicies?
                | (:state) -> ::Temporalio::Api::Schedule::V1::ScheduleState?
                | (::Symbol) -> untyped

          def []=: (:spec, ::Temporalio::Api::Schedule::V1::ScheduleSpec?) -> ::Temporalio::Api::Schedule::V1::ScheduleSpec?
                 | [M < ::Temporalio::Api::Schedule::V1::ScheduleSpec::_ToProto] (:spec, M?) -> M?
                 | (:action, ::Temporalio::Api::Schedule::V1::ScheduleAction?) -> ::Temporalio::Api::Schedule::V1::ScheduleAction?
                 | [M < ::Temporalio::Api::Schedule::V1::ScheduleAction::_ToProto] (:action, M?) -> M?
                 | (:policies, ::Temporalio::Api::Schedule::V1::SchedulePolicies?) -> ::Temporalio::Api::Schedule::V1::SchedulePolicies?
                 | [M < ::Temporalio::Api::Schedule::V1::SchedulePolicies::_ToProto] (:policies, M?) -> M?
                 | (:state, ::Temporalio::Api::Schedule::V1::ScheduleState?) -> ::Temporalio::Api::Schedule::V1::ScheduleState?
                 | [M < ::Temporalio::Api::Schedule::V1::ScheduleState::_ToProto] (:state, M?) -> M?
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> Schedule
          end

          # The type of `#initialize` parameter.
          type init = Schedule | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[Schedule, Schedule | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, Schedule, Schedule | _ToProto]

          type array = ::Array[Schedule | _ToProto]

          type hash[KEY] = ::Hash[KEY, Schedule | _ToProto]
        end

        # ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
        #  that's returned in ListSchedules.
        #
        class ScheduleListInfo < ::Protobuf::Message
          # From spec:
          #  Some fields are dropped from this copy of spec: timezone_data
          #
          attr_accessor spec(): ::Temporalio::Api::Schedule::V1::ScheduleSpec?

          # From spec:
          #  Some fields are dropped from this copy of spec: timezone_data
          #
          def spec=: [M < ::Temporalio::Api::Schedule::V1::ScheduleSpec::_ToProto] (M?) -> M?
                   | ...

          def spec!: () -> ::Temporalio::Api::Schedule::V1::ScheduleSpec?

          # From action:
          #  Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
          #  well with JSON. If action is start_workflow, this is set:
          #
          attr_accessor workflow_type(): ::Temporalio::Api::Common::V1::WorkflowType?

          # From action:
          #  Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
          #  well with JSON. If action is start_workflow, this is set:
          #
          def workflow_type=: [M < ::Temporalio::Api::Common::V1::WorkflowType::_ToProto] (M?) -> M?
                            | ...

          def workflow_type!: () -> ::Temporalio::Api::Common::V1::WorkflowType?

          # From state:
          #
          attr_accessor notes(): ::String

          def notes!: () -> ::String?

          attr_accessor paused(): bool

          def paused!: () -> bool?

          # From info (maybe fewer entries):
          #
          attr_accessor recent_actions(): ::Temporalio::Api::Schedule::V1::ScheduleActionResult::field_array

          # From info (maybe fewer entries):
          #
          def recent_actions=: (::Temporalio::Api::Schedule::V1::ScheduleActionResult::array) -> ::Temporalio::Api::Schedule::V1::ScheduleActionResult::array
                             | ...

          def recent_actions!: () -> ::Temporalio::Api::Schedule::V1::ScheduleActionResult::field_array?

          attr_accessor future_action_times(): ::Google::Protobuf::Timestamp::field_array

          def future_action_times=: (::Google::Protobuf::Timestamp::array) -> ::Google::Protobuf::Timestamp::array
                                  | ...

          def future_action_times!: () -> ::Google::Protobuf::Timestamp::field_array?

          def initialize: (?spec: ::Temporalio::Api::Schedule::V1::ScheduleSpec::init?, ?workflow_type: ::Temporalio::Api::Common::V1::WorkflowType::init?, ?notes: ::String, ?paused: bool, ?recent_actions: ::Temporalio::Api::Schedule::V1::ScheduleActionResult::array, ?future_action_times: ::Google::Protobuf::Timestamp::array) -> void

          def []: (:spec) -> ::Temporalio::Api::Schedule::V1::ScheduleSpec?
                | (:workflow_type) -> ::Temporalio::Api::Common::V1::WorkflowType?
                | (:notes) -> ::String
                | (:paused) -> bool
                | (:recent_actions) -> ::Temporalio::Api::Schedule::V1::ScheduleActionResult::field_array
                | (:future_action_times) -> ::Google::Protobuf::Timestamp::field_array
                | (::Symbol) -> untyped

          def []=: (:spec, ::Temporalio::Api::Schedule::V1::ScheduleSpec?) -> ::Temporalio::Api::Schedule::V1::ScheduleSpec?
                 | [M < ::Temporalio::Api::Schedule::V1::ScheduleSpec::_ToProto] (:spec, M?) -> M?
                 | (:workflow_type, ::Temporalio::Api::Common::V1::WorkflowType?) -> ::Temporalio::Api::Common::V1::WorkflowType?
                 | [M < ::Temporalio::Api::Common::V1::WorkflowType::_ToProto] (:workflow_type, M?) -> M?
                 | (:notes, ::String) -> ::String
                 | (:paused, bool) -> bool
                 | (:recent_actions, ::Temporalio::Api::Schedule::V1::ScheduleActionResult::field_array) -> ::Temporalio::Api::Schedule::V1::ScheduleActionResult::field_array
                 | (:recent_actions, ::Temporalio::Api::Schedule::V1::ScheduleActionResult::array) -> ::Temporalio::Api::Schedule::V1::ScheduleActionResult::array
                 | (:future_action_times, ::Google::Protobuf::Timestamp::field_array) -> ::Google::Protobuf::Timestamp::field_array
                 | (:future_action_times, ::Google::Protobuf::Timestamp::array) -> ::Google::Protobuf::Timestamp::array
                 | (::Symbol, untyped) -> untyped

          def paused?: () -> bool

          interface _ToProto
            def to_proto: () -> ScheduleListInfo
          end

          # The type of `#initialize` parameter.
          type init = ScheduleListInfo | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[ScheduleListInfo, ScheduleListInfo | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, ScheduleListInfo, ScheduleListInfo | _ToProto]

          type array = ::Array[ScheduleListInfo | _ToProto]

          type hash[KEY] = ::Hash[KEY, ScheduleListInfo | _ToProto]
        end

        # ScheduleListEntry is returned by ListSchedules.
        #
        class ScheduleListEntry < ::Protobuf::Message
          attr_accessor schedule_id(): ::String

          def schedule_id!: () -> ::String?

          attr_accessor memo(): ::Temporalio::Api::Common::V1::Memo?

          def memo=: [M < ::Temporalio::Api::Common::V1::Memo::_ToProto] (M?) -> M?
                   | ...

          def memo!: () -> ::Temporalio::Api::Common::V1::Memo?

          attr_accessor search_attributes(): ::Temporalio::Api::Common::V1::SearchAttributes?

          def search_attributes=: [M < ::Temporalio::Api::Common::V1::SearchAttributes::_ToProto] (M?) -> M?
                                | ...

          def search_attributes!: () -> ::Temporalio::Api::Common::V1::SearchAttributes?

          attr_accessor info(): ::Temporalio::Api::Schedule::V1::ScheduleListInfo?

          def info=: [M < ::Temporalio::Api::Schedule::V1::ScheduleListInfo::_ToProto] (M?) -> M?
                   | ...

          def info!: () -> ::Temporalio::Api::Schedule::V1::ScheduleListInfo?

          def initialize: (?schedule_id: ::String, ?memo: ::Temporalio::Api::Common::V1::Memo::init?, ?search_attributes: ::Temporalio::Api::Common::V1::SearchAttributes::init?, ?info: ::Temporalio::Api::Schedule::V1::ScheduleListInfo::init?) -> void

          def []: (:schedule_id) -> ::String
                | (:memo) -> ::Temporalio::Api::Common::V1::Memo?
                | (:search_attributes) -> ::Temporalio::Api::Common::V1::SearchAttributes?
                | (:info) -> ::Temporalio::Api::Schedule::V1::ScheduleListInfo?
                | (::Symbol) -> untyped

          def []=: (:schedule_id, ::String) -> ::String
                 | (:memo, ::Temporalio::Api::Common::V1::Memo?) -> ::Temporalio::Api::Common::V1::Memo?
                 | [M < ::Temporalio::Api::Common::V1::Memo::_ToProto] (:memo, M?) -> M?
                 | (:search_attributes, ::Temporalio::Api::Common::V1::SearchAttributes?) -> ::Temporalio::Api::Common::V1::SearchAttributes?
                 | [M < ::Temporalio::Api::Common::V1::SearchAttributes::_ToProto] (:search_attributes, M?) -> M?
                 | (:info, ::Temporalio::Api::Schedule::V1::ScheduleListInfo?) -> ::Temporalio::Api::Schedule::V1::ScheduleListInfo?
                 | [M < ::Temporalio::Api::Schedule::V1::ScheduleListInfo::_ToProto] (:info, M?) -> M?
                 | (::Symbol, untyped) -> untyped

          interface _ToProto
            def to_proto: () -> ScheduleListEntry
          end

          # The type of `#initialize` parameter.
          type init = ScheduleListEntry | _ToProto

          # The type of `repeated` field.
          type field_array = ::Protobuf::Field::FieldArray[ScheduleListEntry, ScheduleListEntry | _ToProto]

          # The type of `map` field.
          type field_hash[KEY] = ::Protobuf::Field::FieldHash[KEY, ScheduleListEntry, ScheduleListEntry | _ToProto]

          type array = ::Array[ScheduleListEntry | _ToProto]

          type hash[KEY] = ::Hash[KEY, ScheduleListEntry | _ToProto]
        end
      end
    end
  end
end
